# 2.0 Migration Guide

We have heard and appreciate all of the feedback we've gotten over the past
year, and it is very clear: Ditto is maturing and developers want to build more
complex applications. To do that, Ditto needs to expose more of the internal
functionality so that developers have more flexibility and control. Ditto 2.0 is
the first step in that direction.

## Explicit Types

Types can now be made explicit. Ditto 2.0 introduces `DittoRegister` and `Counter` as the first step:

### Counter

* `replaceWithCounter` is deprecated. Instead, use `Counter()` and `increment(double)` 

Counters are always initialized with no parameters in the constructor. This is
to encourage all mutations to happen within an `update` clause. This helps
behavior be more clear -- if you want to have a mutable type, you need to mutate
them using the methods available for that type.

```js
let id = collection.upsert({
  seat: '16c',
  drinks: Counter(),
})
```

```js
collection.findById(id).update(doc => {
  doc.drinks.increment(1)
})
```
### DittoRegister

* Added `DittoRegister` to explicitly create Registers 
* Added Map and Array to the list of valid register types

Map and Array are now valid register types. We call these *Complex
Registers*. Complex Registers allow you to query and access data as their
fundamental type. For example:

```swift
collection.find("array[0] == 1")
collection.find("map['b'] == 'c'")

coll.findByID(docID).update({ mutDoc in 
  let one = mutDoc["array"][0]
}
```

However, updating a complex register is last writer wins for the entire type,
similar to a string or number. These types are useful for pulling data into
Ditto from external databases, where Ditto is rarely modifying that data
internally.

All of the following are valid uses of `DittoRegister` type:

```swift
let content: [String: Any?] = [
    "string": DittoRegister(value: "string in register"),
    "integer": DittoRegister(value: 123),
    "float": DittoRegister(value: 4.56),
    "bool": DittoRegister(value: false),
    "nested": [
        "inner": DittoRegister(value: "simple")
    ],
    "array": DittoRegister(value: [1, 2, 3]),
    "complex_array": DittoRegister(value: [[[["a": 42]]]]),
    "map": DittoRegister(value: ["b": "c"]),
    "complex_map": DittoRegister(value: ["d": ["e": ["f": [["four": 4, "five": 5]]]]])
]

let docID = try! collection.upsert(content)
```

All supported `DittoRegister` types are:

* String
* Numbers (Int, Float, etc)
* Boolean
* null
* Binary
* **Map** (new Complex Register)
* **Array** (new Complex Register)

### Updating a Register

* Only use `set(value)` or `remove()` a Register. Registers cannot be
partially updated. 

For example, say you have a document that contains complex content that inserted from a legacy
database, where all values are registers. To modify a register:

```swift
coll.findByID(docID).update(mutDoc => {
  // This is ok. Retrieves the data at an index
  let one = mutDoc["array"][0]
  
  // To update the array
  let newArray = mutDoc["array"]
  newArray[0] = "foo \(one)"
  // To update the value
  mutDoc["array"].set(DittoRegister(value: newArray))
})
```

You can also update registers using `upsert` but you must not forget to always
wrap your new value with `DittoRegister()`:

```js
coll.upsert({
  "map": DittoRegister(value: newMap)
})
```

The following example code will change the type of your register to a map. Do
not do this.

```swift
coll.findByID(docID).update(mutDoc => {
  // This is not ok. You should not modify a register at an index or path.
  // You will lose any concurrent updates and the type will change.
  mutDoc["complex_map"]["d"]["e"] = "bananas" 
}
```

### HTTP API

* The HTTP API will support explicit types through the `/api/v2/store` endpoint.
* The `/api/v1/store` endpoint is deprecated, and become unsupported in Ditto 3.0.

To create and modify a Register Array, Register Map, or Counter in the HTTP API
for v2, use the `/api/v2/store` endpoint and annotate the value with the type
you intend to use. 

For example, if you want to create a `friends` key with a Register that is an array, use the `register` key:

```json
{
  "value": {
    "_id": "123abc",
    "friends": {
        "register": { "value": ["Susan"] }
    }
  }
}
```

A full example with `curl` that shows how to use the HTTP API with the new `counter` and `register` map types:

```
curl -X POST 'https://<CLOUD_ENDPOINT>/api/v2/store' \
  --header 'X-DITTO-CLIENT-ID: AAAAAAAAAAAAAAAAAAAABQ==' \
  --header 'Content-Type: application/json' \
  --data-raw '{
    "method": "write",
    "parameters": {
      "commands": [{
        "method": "upsert",
        "collection": "people",
        "value": {
          "_id": "123abc",
          "friends": {
             "register": { "value": ["Susan"] }
          },
          "owned_cars": {
             "counter": { "value": 0 }
          },
          "complex_map": {
             "register": { "value": {
                "d": {
                  "e": "bananas"
                }
             }}
          },
        }
      }]
    }
  }'
```

## Growable Arrays

* The [Growable Array](https://docs.ditto.live/android/common/datamodel/array) is deprecated. 
* `.push()` and `.pop()` and `array[0].remove()` are deprecated. 

RGAs will be entirely unsupported in Ditto 3.0, so it is important that you
start migrating away from using Growable Arrays and start using a [DittoRegister](#dittoregister) or a [Map](../datamodel/map/) instead.

We may bring back the Growable Array in 2023 for text editing. However, we do not see the demand for Growable Arrays right
now, so we decided to deprecate it for the time being. Please reach out through
the help center on the bottom right of your screen if you are interested in
Growable Arrays. We would love to hear about your use case.

## Write Strategy
 
* Ditto 2.0 will remove support for the `overwrite` write strategy.


## Sync limits

In 1.x `findAll().limit(10)` would not limit replication by default. This would cause small peers to crash if they accidentally pulled down more data from the Big Peer than their platform or hardware could handle. 

```js
veryLargeCollection.findAll().limit(10).observe(callback) // CRASH!!!!
```

In the 2.0, `limit(10)` will only replicate 10 documents as expected.

```js
veryLargeCollection.findAll().limit(10).observe(callback) // OK
```


## Forward-compatibility with concurrent types

* It is valid to use multiple types concurrently at the same document path. 

Distributed applications typically only add new fields and never remove or
modify existing fields in production. Despite these validation code paths, bugs
happen. It could be possible to have a version of your application that changed
the type of a field that an older application version is using. This would break
the *forward-compatibility* of your software. This could cause a crash in
production if an application version is expecting a different shape to your
data.  

If this happens, Ditto 2.0's concurrent types ensure that data is never lost and that old code can
still work with new data. Devices can always access all types that have been
added to a particular field. Ditto does its best to preserve data, even if the
type was changed by another, incompatible version of your application. This
feature allows you to more easily build forward-compatibile applications. 

It is another tool that Ditto gives you so that you can manage schema changes
more robustly, and reduce the chance of data loss or crashes in production.


Device A

```swift
try! coll.upsert(["edited_by": "john"])
```

Device B
```swift
try! coll.upsert(["edited_by": ["timestamp": 16827219234, "user_id": "abc123"])
```

After syncronization
```swift
const doc = coll.findByID(docID)
doc["edited_by"].value // latest timestamp: ["timestamp": ..., "user_id": ...]
doc["edited_by"].dictionaryValue // ["timestamp": ..., "user_id": ...]
doc["edited_by"].stringValue // "john"
```

